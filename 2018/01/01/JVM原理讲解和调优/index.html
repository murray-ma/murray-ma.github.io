<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JVM原理讲解和调优, Java,Python,GO">
    <meta name="description" content="IT文章及知识分享">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JVM原理讲解和调优 | 马瑞个人笔记</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="马瑞个人笔记" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">马瑞个人笔记</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">马瑞个人笔记</div>
        <div class="logo-desc">
            
            IT文章及知识分享
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JVM原理讲解和调优</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
        padding-bottom: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
        padding-top: 1.5rem
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        <!-- height: calc(100vh - 250px); -->
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java/">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                            <a href="/tags/Jvm/">
                                <span class="chip bg-color">Jvm</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java/" class="post-category">
                                Java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2018-01-01
                </div>
                

                

                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="JVM-原理讲解和调优"><a href="#JVM-原理讲解和调优" class="headerlink" title="JVM 原理讲解和调优"></a>JVM 原理讲解和调优</h2><p>原文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hjxgood/article/details/53896229">https://blog.csdn.net/hjxgood/article/details/53896229</a></p>
<h3 id="一、什么是-JVM"><a href="#一、什么是-JVM" class="headerlink" title="一、什么是 JVM"></a>一、什么是 JVM</h3><p>JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，JVM 是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>
<p>Java 语言的一个非常重要的特点就是与平台的无关性。而使用 Java 虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入 Java 语言虚拟机后，Java 语言在不同平台上运行时不需要重新编译。Java 语言使用 Java 虚拟机屏蔽了与具体平台相关的信息，使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是 Java 的能够”一次编译，到处运行”的原因。</p>
<p>从 Java 平台的逻辑结构上来看，我们可以从下图来了解 JVM：</p>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-1.gif"></p>
<p>从上图能清晰看到 Java 平台包含的各个逻辑模块，也能了解到 JDK 与 JRE 的区别，对于 JVM 自身的物理结构，我们可以从下图鸟瞰一下：</p>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-2.gif"></p>
<h3 id="二、JAVA-代码编译和执行过程"><a href="#二、JAVA-代码编译和执行过程" class="headerlink" title="二、JAVA 代码编译和执行过程"></a>二、JAVA 代码编译和执行过程</h3><p>Java 代码编译是由 Java 源码编译器来完成，流程图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-3.gif"></p>
<p>Java 字节码的执行是由 JVM 执行引擎来完成，流程图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-4.gif"></p>
<p>Java 代码编译和执行的整个过程包含了以下三个重要的机制：</p>
<ul>
<li>Java 源码编译机制</li>
<li>类加载机制</li>
<li>类执行机制</li>
</ul>
<h4 id="Java-源码编译机制"><a href="#Java-源码编译机制" class="headerlink" title="Java 源码编译机制"></a>Java 源码编译机制</h4><p>Java 源码编译由以下三个过程组成：</p>
<ul>
<li>分析和输入到符号表</li>
<li>注解处理</li>
<li>语义分析和生成 class 文件</li>
</ul>
<p>流程图如下所示：<br><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-5.gif"></p>
<p>最后生成的 class 文件由以下部分组成：</p>
<ul>
<li>结构信息。包括 class 文件格式版本号及各部分的数量与大小的信息</li>
<li>元数据。对应于 Java 源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池</li>
<li>方法信息。对应 Java 源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息</li>
</ul>
<h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><p>JVM 的类加载是通过 ClassLoader 及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：</p>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-6.gif"></p>
<ul>
<li>1）Bootstrap ClassLoader<br>负责加载$JAVA_HOME 中 jre/lib/rt.jar 里所有的 class，由 C++实现，不是 ClassLoader 子类</li>
<li>2）Extension ClassLoader<br>负责加载 java 平台中扩展功能的一些 jar 包，包括$JAVA_HOME 中 jre/lib/*.jar 或-Djava.ext.dirs 指定目录下的 jar 包</li>
<li>3）App ClassLoader<br>负责记载 classpath 中指定的 jar 包及目录中 class</li>
<li>4）Custom ClassLoader<br>属于应用程序根据自身需要自定义的 ClassLoader，如 tomcat、jboss 都会根据 j2ee 规范自行实现 ClassLoader 加载过程中会先检查类是否被已加载，检查顺序是自底向上，从 Custom ClassLoader 到 BootStrap ClassLoader 逐层检查，只要某个 classloader 已加载就视为已加载此类，保证此类只所有 ClassLoader 加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</li>
</ul>
<h4 id="类执行机制"><a href="#类执行机制" class="headerlink" title="类执行机制"></a>类执行机制</h4><p>JVM 是基于栈的体系结构来执行 class 字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。栈的结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-7.gif"></p>
<h3 id="三、JVM-内存管理和垃圾回收"><a href="#三、JVM-内存管理和垃圾回收" class="headerlink" title="三、JVM 内存管理和垃圾回收"></a>三、JVM 内存管理和垃圾回收</h3><h4 id="JVM-内存组成结构"><a href="#JVM-内存组成结构" class="headerlink" title="JVM 内存组成结构"></a>JVM 内存组成结构</h4><p>JVM 栈由堆、栈、本地方法栈、方法区等部分组成，结构图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-8.gif"></p>
<h5 id="1）堆"><a href="#1）堆" class="headerlink" title="1）堆"></a>1）堆</h5><p>所有通过 new 创建的对象的内存都在堆中分配，堆的大小可以通过-Xmx 和-Xms 来控制。堆被划分为新生代和旧生代，新生代又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Space 和 To Space 组成，结构图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-9.gif"></p>
<ul>
<li>新生代。新建的对象都是用新生代分配内存，Eden 空间不足的时候，会把存活的对象转移到 Survivor 中，新生代大小可以由-Xmn 来控制，也可以用-XX:SurvivorRatio 来控制 Eden 和 Survivor 的比例</li>
<li>旧生代。用于存放新生代中经过多次垃圾回收仍然存活的对象</li>
<li>持久带（Permanent Space）实现方法区，主要存放所有已加载的类信息，方法信息，常量池等等。可通过-XX:PermSize 和-XX:MaxPermSize 来指定持久带初始化值和最大值。Permanent Space 并不等同于方法区，只不过是 Hotspot JVM 用 Permanent Space 来实现方法区而已，有些虚拟机没有 Permanent Space 而用其他机制来实现方法区。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-14.jpeg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xmx:最大堆内存,如：-Xmx512m</span><br><span class="line">-Xms:初始时堆内存,如：-Xms256m</span><br><span class="line">-XX:MaxNewSize:最大年轻区内存</span><br><span class="line">-XX:NewSize:初始时年轻区内存.通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%</span><br><span class="line">-XX:MaxPermSize:最大持久带内存</span><br><span class="line">-XX:PermSize:初始时持久带内存</span><br><span class="line">-XX:+PrintGCDetails。打印 GC 信息</span><br><span class="line">-XX:NewRatio 新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3</span><br><span class="line">-XX:SurvivorRatio 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10</span><br></pre></td></tr></table></figure>

<h5 id="2）栈"><a href="#2）栈" class="headerlink" title="2）栈"></a>2）栈</h5><p>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。<br>-xss:设置每个线程的堆栈大小. JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。</p>
<h5 id="3）本地方法栈"><a href="#3）本地方法栈" class="headerlink" title="3）本地方法栈"></a>3）本地方法栈</h5><p>用于支持 native 方法的执行，存储了每个 native 方法调用的状态</p>
<h5 id="4）方法区"><a href="#4）方法区" class="headerlink" title="4）方法区"></a>4）方法区</h5><p>存放了要加载的类信息、静态变量、final 类型的常量、属性和方法信息。JVM 用持久代（Permanet Generation）来存放方法区，可通过-XX:PermSize 和-XX:MaxPermSize 来指定最小值和最大值</p>
<h4 id="垃圾回收按照基本回收策略分"><a href="#垃圾回收按照基本回收策略分" class="headerlink" title="垃圾回收按照基本回收策略分"></a>垃圾回收按照基本回收策略分</h4><p>引用计数（Reference Counting）:</p>
<p>比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为 0 的对象。此算法最致命的是无法处理循环引用的问题。</p>
<p>标记-清除（Mark-Sweep）:</p>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-10.jpeg"></p>
<p>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p>
<p>复制（Copying）:</p>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-11.jpeg"></p>
<p>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现”碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</p>
<p>标记-整理（Mark-Compact）:</p>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-12.jpeg"></p>
<p>此算法结合了”标记-清除”和”复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象”压缩”到堆的其中一块，按顺序排放。此算法避免了”标记-清除”的碎片问题，同时也避免了”复制”算法的空间问题。</p>
<h3 id="JVM-分别对新生代和旧生代采用不同的垃圾回收机制"><a href="#JVM-分别对新生代和旧生代采用不同的垃圾回收机制" class="headerlink" title="JVM 分别对新生代和旧生代采用不同的垃圾回收机制"></a>JVM 分别对新生代和旧生代采用不同的垃圾回收机制</h3><h4 id="新生代的-GC："><a href="#新生代的-GC：" class="headerlink" title="新生代的 GC："></a>新生代的 GC：</h4><p>新生代通常存活时间较短，因此基于 Copying 算法来进行回收，所谓 Copying 算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在 Eden 和 From Space 或 To Space 之间 copy。新生代采用空闲指针的方式来控制 GC 触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发 GC。当连续分配对象时，对象会逐渐从 eden 到 survivor，最后到旧生代。<br>在执行机制上 JVM 提供了串行 GC（Serial GC）、并行回收 GC（Parallel Scavenge）和并行 GC（ParNew）</p>
<h5 id="1）串行-GC"><a href="#1）串行-GC" class="headerlink" title="1）串行 GC"></a>1）串行 GC</h5><p>在整个扫描和复制过程采用单线程的方式来进行，适用于单 CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是 client 级别默认的 GC 方式，可以通过-XX:+UseSerialGC 来强制指定</p>
<h5 id="2）并行回收-GC"><a href="#2）并行回收-GC" class="headerlink" title="2）并行回收 GC"></a>2）并行回收 GC</h5><p>在整个扫描和复制过程采用多线程的方式来进行，适用于多 CPU、对暂停时间要求较短的应用上，是 server 级别默认采用的 GC 方式，可用-XX:+UseParallelGC 来强制指定，用-XX:ParallelGCThreads=4 来指定线程数</p>
<h5 id="3）并行-GC"><a href="#3）并行-GC" class="headerlink" title="3）并行 GC"></a>3）并行 GC</h5><p>与旧生代的并发 GC 配合使用</p>
<h4 id="旧生代的-GC："><a href="#旧生代的-GC：" class="headerlink" title="旧生代的 GC："></a>旧生代的 GC：</h4><p>旧生代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记（Mark）算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗。在执行机制上 JVM 提供了串行 GC（Serial MSC）、并行 GC（parallel MSC）和并发 GC（CMS），具体算法细节还有待进一步深入研究。</p>
<p>以上各种 GC 机制是需要组合使用的，指定方式由下表所示：</p>
<table>
<thead>
<tr>
<th>指定方式</th>
<th>新生代 GC 方式</th>
<th>旧生代 GC 方式</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseSerialGC</td>
<td>串行 GC</td>
<td>串行 GC</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>并行回收 GC</td>
<td>并行 GC</td>
</tr>
<tr>
<td>-XX:+UseConeMarkSweepGC</td>
<td>并行 GC</td>
<td>并发 GC</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>并行 GC</td>
<td>串行 GC</td>
</tr>
<tr>
<td>-XX:+UseParallelOldGC</td>
<td>并行回收 GC</td>
<td>并行 GC</td>
</tr>
<tr>
<td>-XX:+ UseConeMarkSweepGC-XX:+UseParNewGC</td>
<td>串行 GC</td>
<td>并发 GC</td>
</tr>
<tr>
<td>不支持的组合</td>
<td>1、-XX:+UseParNewGC -XX:+UseParallelOldGC2、-XX:+UseParNewGC -XX:+UseSerialGC</td>
<td></td>
</tr>
</tbody></table>
<h3 id="四、JVM-内存调优"><a href="#四、JVM-内存调优" class="headerlink" title="四、JVM 内存调优"></a>四、JVM 内存调优</h3><p>首先需要注意的是在对 JVM 内存调优的时候不能只看操作系统级别 Java 进程所占用的内存，这个数值不能准确的反应堆内存的真实占用情况，因为 GC 过后这个值是不会变化的，因此内存调优的时候要更多地使用 JDK 提供的内存查看工具，比如 JConsole 和 Java VisualVM。</p>
<p>对 JVM 内存的系统级的调优主要的目的是减少 GC 的频率和 Full GC 的次数，过多的 GC 和 Full GC 是会占用很多的系统资源（主要是 CPU），影响系统的吞吐量。特别要关注 Full GC，因为它会对整个堆进行整理，导致 Full GC 一般由于以下几种情况：</p>
<h4 id="旧生代空间不足"><a href="#旧生代空间不足" class="headerlink" title="旧生代空间不足"></a>旧生代空间不足</h4><p>调优时尽量让对象在新生代 GC 时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pemanet Generation空间不足</span><br><span class="line">    增大Perm Gen空间，避免太多静态对象</span><br><span class="line">    统计得到的GC后晋升到旧生代的平均大小大于旧生代剩余空间</span><br><span class="line">    控制好新生代和旧生代的比例</span><br><span class="line">System.gc()被显示调用</span><br><span class="line">    垃圾回收不要手动触发，尽量依靠JVM自身的机制</span><br><span class="line">    调优手段主要是通过控制堆内存的各个部分的比例和GC策略来实现，下面来看看各部分比例不良设置会导致什么后果</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1）新生代设置过小</span><br><span class="line">    一是新生代GC次数非常频繁，增大系统消耗；二是导致大对象直接进入旧生代，占据了旧生代剩余空间，诱发Full GC</span><br><span class="line">2）新生代设置过大</span><br><span class="line">    一是新生代设置过大会导致旧生代过小（堆总量一定），从而诱发Full GC；二是新生代GC耗时大幅度增加</span><br><span class="line">    一般说来新生代占整个堆1/3比较合适</span><br><span class="line">3）Survivor设置过小</span><br><span class="line">    导致对象从eden直接到达旧生代，降低了在新生代的存活时间</span><br><span class="line">4）Survivor设置过大</span><br><span class="line">    导致eden过小，增加了GC频率</span><br><span class="line">    另外，通过-XX:MaxTenuringThreshold=n来控制新生代存活时间，尽量让对象在新生代被回收</span><br><span class="line">    由内存管理和垃圾回收可知新生代和旧生代都有多种GC策略和组合搭配，选择这些策略对于我们这些开发人员是个难题，JVM提供两种较为简单的GC策略的设置方式</span><br><span class="line">1）吞吐量优先</span><br><span class="line">    JVM以吞吐量为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，来达到吞吐量指标。这个值可由-XX:GCTimeRatio=n来设置</span><br><span class="line">2）暂停时间优先</span><br><span class="line">    JVM以暂停时间为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，尽量保证每次GC造成的应用停止时间都在指定的数值范围内完成。这个值可由-XX:MaxGCPauseRatio=n来设置</span><br></pre></td></tr></table></figure>

<p>最后汇总一下 JVM 常见配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">堆设置</span><br><span class="line">-Xms:初始堆大小</span><br><span class="line">-Xmx:最大堆大小</span><br><span class="line">-XX:NewSize=n:设置年轻代大小</span><br><span class="line">-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</span><br><span class="line">-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</span><br><span class="line">-XX:MaxPermSize=n:设置持久代大小</span><br><span class="line">收集器设置</span><br><span class="line">-XX:+UseSerialGC:设置串行收集器</span><br><span class="line">-XX:+UseParallelGC:设置并行收集器</span><br><span class="line">-XX:+UseParalledlOldGC:设置并行年老代收集器</span><br><span class="line">-XX:+UseConcMarkSweepGC:设置并发收集器</span><br><span class="line">垃圾回收统计信息</span><br><span class="line">-XX:+PrintGC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-Xloggc:filename</span><br><span class="line">并行收集器设置</span><br><span class="line">-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</span><br><span class="line">-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</span><br><span class="line">-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</span><br><span class="line">并发收集器设置</span><br><span class="line">-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</span><br><span class="line">-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</span><br></pre></td></tr></table></figure>

<p>++++++++++++++++++++++++++++++++另外一篇+++++++++++++++++++++++++++++++++++++</p>
<p>Jvm 与 c++不同，它实现了内存的自动分配和回收，这种机制使程序员无需关注内存的使用和回收，正是这种情况往往造成程序与 jvm 内存的分配和回收机制不匹配，从而出现各种问题。比如程序代码量很大，虚拟机永久区内存不足，会抛出 outofmemoryerror 错误，代码中全局大对象很多导致垃圾回收时间变长，应用出现卡顿现象等。当这二者不匹配时，有时候可能是代码编写不合理造成的，例如上面第二个现象。也有时候需要我们调节 jvm 各个参数，优化内存的分配和回收，使 jvm 满足我们程序的要求，比如程序代码量很大，我们要调大永久区，才不会抛出 outofmemoryerror。总之，无论哪种现象都需要我们充分理解 jvm 的内存机制的基础上，才能解决问题，上一篇讲了 jvm 的垃圾回收机制，这一篇我们要充分理解下 jvm 的内存区域和 jvm 调优时用到的各个参数。</p>
<p>根据 jvm 规范的规定，jvm 的内存区域包括：程序计数器、栈、堆、方法区、运行时常量池。这几块区域可以分为三部分：线程堆栈（程序计数器、栈）、堆、非堆（包括方法区、运行时常量池）。</p>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>线程堆栈是表示 jvm 给每个线程分配的内存大小，jdk5.0 以后每个线程分配的内存大小是 1 M，这个值的调节是通过-Xss 设置。在线程中，每个方法使用和结束就意味着一个栈帧的入栈和出栈，若方法中使用较大深度的递归或者较大循环时，就会导致大量栈帧入栈，内存空间不足，抛出 stackoverflowerror 错误。因此，若 jvm 抛出 stackoverflowerror 错误时，就需要调节-xss 参数，扩大栈的空间，或者检查代码，查看是否有较大（或无限）深度递归或循环，如果是代码有问题，修改代码，若代码无问题，需通过-Xss 参数扩大栈空间。在 jvm 默认参数下，栈深度在大多数情况下达到 1000 到 2000 完全没有问题，对于正常的方法调用，这个深度是完全够用的。若每个栈的空间变大，在操作系统物理空间内存不变的情况下的，可生成的线程数量就会变少。在 32 位操作系统下，每个进程可分配的内存大概是 2GB，64 位操作系统无限制，但是物理内存大小是固定的，是有限制的。因此，当在多线程应用中，每增加一个线程就需要多占用物理内存 1M，若物理内存或者进程分配的内存不足时，这是 jvm 生成新的线程时就会产生 outofmemoryerror 错误。因为堆或非堆内存不足也会抛出 outofmemoryerror 错误，因此当出现这种问题，要具体分析是哪部分空间不足，若物理内存（或进程分配的内存）已占满，堆内存和非堆内存空间都在正常的使用范围内，那么问题就出现在堆栈空间不足，要么增加物理内存，要么减少堆空间（这种方式可能不合理）。所以这一部分，如果 jvm 没有出现错误，保持默认配置即可。</p>
<h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>大家更关注的往往是堆内存的分配和回收，这部分是 jvm 需要优化的主战场，垃圾回收主要是针对堆内存，jvm 垃圾回收的频率和时间是程序运行好坏的重要指标，因为垃圾回收要终止其它正常的工作线程，导致程序停顿。影响 Jvm 垃圾回收的频率和时间因素，除了垃圾收集器自身的实现机制外，堆内存的大小或各带（堆分代设置）比例设置等也是重要的因素。调节堆内存的参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Xms 1024M  //表示堆内存初始化大小，默认是物理内存1/64;</span><br><span class="line">-Xmx 1024M  //表示堆内存最大值，默认是物理内存1/4;</span><br><span class="line">-Xmn 512M  //表示堆中新生代大小；</span><br><span class="line">-XX:NewRadio  //表示新生代与老年代的比例，-XX:NewRadio =2表示比例为1:2；</span><br><span class="line">-XX:SurvivorRadio   //表示新生代中eden区与survivor区的比例，默认比例为8；</span><br></pre></td></tr></table></figure>

<p>Jvm 中堆内存分为新生代和老年代，新生代又分为 eden 区和两个 survivor 区，其中 eden 区和 survivor 区默认比例是 8:1。新生代中垃圾回收采用复制算法，每次对 eden 区和其中一个 survivor 区执行垃圾回收，然后将存活的对象复制到另一个 survivor 区中，因此，新生代只能使用 90%的空间。一般来说，对象首先进入新生代的 eden 区，经过若干次（默认是 15 次）回收后，若还存活，则进入老年代，这个回收次数相关的参数设置是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold  //表示经过多少次回收，对象进入老年代，默认是15；</span><br></pre></td></tr></table></figure>

<p>对于这个参数，对象并不是都必须经过 15 次回收后进入老年代，若 survivor 区中的经过相同回收次数的对象占 survivor 空间的一半以上时，大于或等于这个次数的对象就可以直接进入老年代。但是，对于一些大对象可以设置直接进入老年代，以避免对新生代中 eden 区和两个 survivor 区之间发生大量的内存复制，因为大对象需要足够大的空间，导致新生代空间还相对充足时就提前执行垃圾回收来获取足够的连续空间来安置大对象。Jvm 提供了一个参数用来设置大对象直接进入老年代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:PretenureSizeThreshold  //直接进入老年代对象的值的阈值，-XX:PretenureSizeThreshold=3M,表示大于3M的对象可以直接 进入老年代</span><br></pre></td></tr></table></figure>

<p>以上是 jvm 中堆内存设置相关的部分参数，在实际的应用中有些设置可以参考很多的经验总结，比如 xms 与 xmx 值设置相同，性能才能最好，因为这样可以避免每次垃圾回收进行内存重新分配，使更多的资源用在具体的应用中。然而也有些设置需要参考具体应用，比如 eden 区、survivor 区和老年代等各空间的大小和比例，是否能满足当前的应用，都需要根据具体应用调整各个区内存的大小和比例。现今，硬件可以说已经不是阻碍程序提高性能的瓶颈了，尤其是内存，目前使用的操作系统基本上都是 64 位了，16G、32G 的内存条已经很普遍了。若堆中某区因空间不足而出现 outofmemoryerror 错误或者程序反应很慢，我们完全可以增大相应的内存来解决。当然一味的增加内存，使 jvm 不会抛出 outofmemroryerror 错误，但是有可能会造成一次需要回收的对象增多，回收时间变长，程序出现明显卡顿，从而影响应用的使用，也是不合理的。因此，我们在对 jvm 堆内存调优时，在保证内存足够用的同时，还要关注的就是各带之间的比例关系，eden 区和 survivor 区之间的默认比例是 8:1，一般按照这个比例设置即可。需要关注的是新生代与老年代之间内存大小比例，新生代不能太小否则会频繁执行 minor gc，老年代也不能太小，否则新生代中的对象无法进入老年代，只好频繁执行 full gc，总之这个比例，查看了很多资料也没有确定的值，还是要根据实际的应用来确定。</p>
<h3 id="非堆内存"><a href="#非堆内存" class="headerlink" title="非堆内存"></a>非堆内存</h3><h4 id="code-cache"><a href="#code-cache" class="headerlink" title="code cache"></a>code cache</h4><p>对于非堆区，jdk7 及以前版本包括：code cache 和 perm gen，jdk8 中包括 code cache、metaspace 和 compressed class space。它们有共同的部分就是 codecache，首先理解下 code cache。在 jvm 调优时一般不太关注 code cache，很少因为它的空间不足造成性能下降，理解 code cache，先理解 java 编译器。对于 java 编译器，把 java 文件编译成为 class 文件，我们称为前端编译，对应的，将 class 文件中的字节码编译称为机器码称为后端编译，最初，hotspot 虚拟机运行时，是对字节码逐条解析，这种方式比较慢，后台 hotspot 引入了 jit 编译器，对于那些被频繁使用的方法，即热点代码，jit 编译器将这些热点代码编译成本地机器码，保存 jvm 内存中，虚拟机运行时需要调用这些方法时，直接从内存中获取，这样效率就会更高。上面所讲的被保存的机器码就是 code cache。 code cache 大小在 client 模式是 32M，在 server 模式是 48M，但是，这个数值在 jdk7 或以前版本中是这么规定的，在 jdk8 中好像不是这么规定的，通过 jconsole 查看 code cache 大小：</p>
<p><img src="https://raw.githubusercontent.com/sunglowrise/images/master/note/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98-13.jpeg"></p>
<p>Code cache 的大小并不是 48M。当 code cache 占满时，会停止方法的编译，进而影响性能。</p>
<h3 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h3><p>对于 perm gen，也就是被称为永久代，在 jdk8 中已经移除了永久带，但在 jdk7 中是存在的，若应用还在使用 jdk7 时，对永久带的调优参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=512M  //永久区初始大小</span><br><span class="line">-XX:MaxPermSize=512M  //永久区最大值</span><br></pre></td></tr></table></figure>

<p>实际应用中，也是将 permsize 与 maxpermsize 设置相同值，性能达到最好。知道永久区调节参数后，我们要明白永久区的作用，jvm 运行时哪些内容存储在永久区中，这样永久区出现内存溢出时，才能明确地调整。在 Hotspot 中，一般把方法区称为永久代，方法区中存放两部分内容，一个是类信息（类版本、字段、方法、接口等描述信息），另一个就是常量池，包括字面量（字符串、被 final 修饰的常量值等）和符号引用。可知，永久区主要存储的就是 class 文件相关的内容，所以若应用的工程很大，代码量很大，那么永久区被占的空间就很大。永久区内存不足时，jvm 会抛出 outofmemoryerror:permgenspace 错误。需要注意的是在 jdk7 中已将将字符串常量移动到堆中，不会因字符串常量很大，使永久区不足。永久区中的垃圾回收主要针对两种类型：被废弃的常量和已卸载的类，被废弃的常量就是没有任何地方引用这个字面量了，这个比较简单。已卸载的类相对来说就很复杂了，一个类被称为已卸载的类须满足三个条件：1.该类所有实例已经被回收；2.加载该类的 classloader 已经被回收；3.该类对应的 java.lang.Class 对象没有在任何地方被引用。所以，永久区垃圾回收比较困难，所以 jvm 在对永久区垃圾回收采用的策略是永久区被使用空间达到 maxPermSize 时，执行 full gc，只要永久区在正确的大小值时不执行垃圾回收。总之，永久代、老年代和新生代都称为 jvm 内存，它们的内存分配和回收受 jvm 控制，除非当内存不足时，需要向操作系统扩张空间时。</p>
<h3 id="metaspace-区"><a href="#metaspace-区" class="headerlink" title="metaspace 区"></a>metaspace 区</h3><p>在 jdk8 中已经不存在永久区了，因此关于永久区调优的参数已经不再适用了，即使用了，jvm 会报警但不会出错。代替永久区的是 metaspace。原先在永久代中的常量池中的字面量移动到堆中，类信息和符号引用被保留在现在被称为 metaspace 的区域中，这样做的好处，我想更有利于 jvm 的内存分配和回收，常量的回收条件毕竟比类的回收更简单。Metaspace 内存调节参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=100M  //表示metaspace使用空间达到这个值时，执行垃圾回收</span><br><span class="line">-XX:MaxMetaspaceSize=100M  //metaspace的最大值</span><br></pre></td></tr></table></figure>

<p>默认情况下，metaspace 是没有最大值的，因为 metaspace 不是 jvm 内存的一部分，它是属于本地内存，内存的分配由操作系统负责。一般来说，metaspace 不需要设置相关参数，若这个区域内存溢出，说明物理内存已经不足，需要增加内存卡了。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>Jvm 还有一部分内存称为直接内存（direct memory），这部分内存不是 jvm 规范的内存区域，也不在堆内存中。这一部分内存主要是为 nio（new input/output）操作准备的，使用 native 函数分配堆外内存，然后通过存储在 java 堆中的 directbytebuffer 对象作为对这块内存的引用进行操作。直接内存不属于堆内存，这部分若内存不足也会抛出 outofmemoryerror:direct buffer memory 错误，直接内存通过下面参数调整大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxDirectMemorySize  //调整直接内存大小</span><br></pre></td></tr></table></figure>

<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>Jvm 调优无非就是两点，一是 jvm 不能抛出异常，比如 stackoverflowerror、outofmemoryerror 等，二是 jvm 性能要满足实际的应用，不能出现卡段或长时间不反应等现象，尤其是高并发时。上面讲的内容已经解决了第一点的问题，对于第二点的问题，是关于 jvm 内存各区之间的内存比例设置和各区垃圾收集器的使用。各区之间的内存比例需要根据实际的情况具体分析，没有一个放之四海皆准的比例参数供我们选择。另一篇文章讲了各个垃圾收集器的原理，本文再次对垃圾收集器进行归纳总结下，hotspot 虚拟机使用的垃圾收集器可分为三种类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">串行收集器，单线程收集器，收集器工作需要停止工作线程；</span><br><span class="line">并行收集器，多线程收集器，收集器工作需要停止工作线程；</span><br><span class="line">并发收集器，多线程收集器，在收集器工作的部分阶段需要停止工作线程；</span><br></pre></td></tr></table></figure>

<p>在 hotspot 虚拟机中垃圾收集器按照这三种虚拟机类型划分：</p>
<ul>
<li>串行收集器：serial 收集器（用于 client 模式，基本上被弃用），serial old 收集器（用于老年代，采用标记整理算法，也被称为 ps marksweep 收集器，若老年代采用此收集器，那么新生代只能使用 parallel scavenge 收集器）。</li>
<li>并行收集器：parnew 收集器（用于新生代，采用复制算法，若老年代使用 cms 收集器那么新生代只能使用这个收集器）、parallelscavenge 收集器（用于新生代，采用复制算法，与 serialold 收集器配合使用）、parallel old 收集器（parallel scavenge 收集器用于老年代的版本，采用标记-整理算法）。</li>
<li>并发收集器：cms 收集器（用于老年代，标记清除算法）。</li>
</ul>
<p>垃圾收集器调节相关参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC:在新生代和老年代使用串行收集器</span><br><span class="line">-XX:+UseParNewGC:在新生代使用并行收集器</span><br><span class="line">-XX:+UseParallelOldGC:老年代使用并行回收收集器</span><br><span class="line">-XX:ParallelGCThreads:设置用于垃圾回收的线程数。通常情况下可以和CPU数量相等，但在CPU数量较多的情况下，设置相对较小的数值也是合理的。</span><br><span class="line">-XX:MaxGCPauseMillis:设置最大垃圾收集停顿时间。他的值是一个大于0的整数。收集器在工作时，会调整Java堆大小或者其他参数，尽可能把停顿时间控制在MaxGCPauseMillis以内。</span><br><span class="line">-XX:GCTimeRatio:设置吞吐量大小。它是0-100的整数。假设GCTimeRatio的值为n，那么系统将花费不超过1/(1+n)的时间用于垃圾收集。</span><br><span class="line">-XX:+UseAdaptiveSizePolicy:打开自适应GC策略。在这种模式下，新生代的大小、eden和survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</span><br><span class="line">-XX:+UseConcMarkSweepGC:新生代使用并行收集器，老年代使用CMS并发收集器</span><br><span class="line">-XX:ParallelCMSThreads:设定CMS的线程数量</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction:设置CMS收集器在老年代空间被使用多少后触发，默认为68%</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection:设置CMS收集器完成垃圾收集后是否要进行一次内存碎片的整理</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction:设定进行多少次CMS垃圾回收后，进行一次内存压缩</span><br><span class="line">-XX:+CMSClassUnloadingEnabled:允许对类元数据区进行回收</span><br><span class="line">-XX:CMSInitiatingPermOccupancyFraction:当永久区占用率达到这一百分比时，启动CMS回收(前提是-XX:+CMSClassUnloadingEnabled激活了)</span><br><span class="line">-XX:UseCMSInitiatingOccupancyOnlyn:表示只在到达阈值的时候才进行CMS回收</span><br><span class="line">-XX:+CMSIncrementalMode:使用增量模式，比较适合单CPU。增量模式在JDK 8中标记为废弃，并将在JDK 9中彻底移除。</span><br><span class="line">-XX:+UseG1GC：表示使用g1收集器，g1收集器不同于其它收集器，不区分年轻代和老年代。</span><br></pre></td></tr></table></figure>

<p>实际参数设置<br>在实际中对 jvm 的调优参数设置，以 tomcat 为例，在 bin 文件下创建 setenv.bat（window 操作系统）文件，然后在文件输入以下相应内容格式即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setjava_home=D:\Program Files\Java\jdk1.7.0_80</span><br><span class="line">setjava_opts=%java_opts% -server -Xms1024M -Xmx1024M -Xss1M</span><br><span class="line">rem-XX:MetaspaceSize=100M -XX:MaxMetaspaceSize=100M</span><br></pre></td></tr></table></figure>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Murray</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.rainbowrise.top/2018/01/01/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98/">https://www.rainbowrise.top/2018/01/01/JVM%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%B0%83%E4%BC%98/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Murray</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Java/">
                                    <span class="chip bg-color">Java</span>
                                </a>
                            
                                <a href="/tags/Jvm/">
                                    <span class="chip bg-color">Jvm</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC81NTE3MC8zMTYzNw==">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2018/01/01/Ibatis%E7%9B%B8%E5%85%B3/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="Ibatis相关">
                        
                        <span class="card-title">Ibatis相关</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2018-01-01
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2018/01/01/Java%E4%B8%ADRSA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="Java中RSA非对称密钥加解密使用示例">
                        
                        <span class="card-title">Java中RSA非对称密钥加解密使用示例</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2018-01-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/PKI/">
                        <span class="chip bg-color">PKI</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 马瑞个人笔记<br />'
            + '文章作者: Murray<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2018-2024</span>
            
            <span id="year">2018</span>
            <a href="/about" target="_blank">Murray</a>
            <!-- |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a> -->
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                &nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                &nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            
            <br><span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2018";
                    var startMonth = "08";
                    var startDate = "13";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            
            <br><span id="icp"><img src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="https://beian.miit.gov.cn" target="_blank">浙ICP备2021006498号</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/sunglowrise" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:sunglowrise@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>











    <a href="https://www.zhihu.com/people/ma-liang-19-36" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/ma-liang-19-36" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
